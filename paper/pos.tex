\section{Proofs of Storage} \label{sect:pos}

We adopt Juels and Kaliski's proof-of-retrievability (POR) scheme~\cite{JK07}.
However, we do not require a full-fledged POR scheme for our purposes.
Our setting has the following distinctive characteristics in comparison to those previous POR schemes:
\begin{itemize}
 \item Distributed storage
 \item Asynchronous proof generation: A POS can be generated by each worker individually without being dependent on other workers.
 \item Static \& dynamic data: The owner can dynamically update its datasets stored on the server, but the data delegated to workers is static.
 \item Untrusted data owner and workers: The data owner may refuse to accept a correctly generated POS from an honest worker.
\end{itemize}

Our scheme bears some similarity with HAIL~\cite{BJO09b}, a distributed POR system.
However, the latter focuses on integrity and availability of files stored in a collection of distributed servers using file authentication techniques and error-correcting code.

- we don't need retrievability, i.e., erasure code

- malicious worker may refuse to release computed results (we discuss how to deal with this problem in \S~\ref{sect:fairness})

- we need to use an encryption scheme which supports secure computation over encrypted data

- one challenge is how to reduce the number of verification required over multiple workers (currently a prover can convince a verifier with a constant number of challenges/responses for each file). The number of queried sentinels should be small because they're for one-time use.

\subsection{Definition} \label{sect:pos-definition}

We give a definition of a proof-of-storage (POS) scheme that suits our purposes:
\begin{itemize}
\item \Setup($\lambda$) $\rightarrow \MK$: The setup algorithm takes as input a security parameter $\lambda$ and outputs a master key $\MK$, from which additional keys are derived, including encryption key $\EK$ and challenge key $\CK$.

\item \Challenge($\CK, S$) $\rightarrow V$: The challenge algorithm takes as input a challenge key $\CK$ and a set $S$ of block indices, and outputs the corresponding set $V$ of challenge block indices.

\item \Response($V$) $\rightarrow R$: The response algorithm takes as a set of challenge indices and outputs the corresponding set $R$ of responses.

\item \Verify($\CK, \EK, R$) $\rightarrow \{0,1\}$: The verify algorithm takes as input the challenge key and encryption key $\EK$, and the responses $R$. It outputs `1' if verification suceeds, or `0' otherwise.
\end{itemize}

In comparison with the original definition by Juels and Kaliski~\cite{JK07}, we omit the encode and extract algorithms which are irrelevant to us.

\subsection{Construction} \label{sect:pos-construction}

\paragraph{Notation.}
We let $n$ denote the number of blocks of the client's entire dataset, and $s$ denote the number of sentinels, i.e., random blocks containing fake values.



\begin{figure*}[htb]\centering
  \begin{tabular}{|l|}
    \hline 
    \parbox{0.95\textwidth}{
    \begin{itemize}[leftmargin=*]
    \item \Setup($\lambda$) $\rightarrow k$: The key generation algorithm takes as input a security parameter $\lambda$ and outputs a secret key $k$.

    \item \Challenge($k, m$) $\rightarrow V$: The encryption algorithm takes as input a secret key $k$ and a message $m$, and outputs the corresponding ciphertext $V$.

    \item \Response($k, V$) $\rightarrow m$: The decryption algorithm takes as input a ciphertext $V$ and a secret key $k$, and outputs the corresponding message $m$ if the key $k$ is correct.

    \item \Verify($k, V$) $\rightarrow m$: The decryption algorithm takes as input a ciphertext $V$ and a secret key $k$, and outputs the corresponding message $m$ if the key $k$ is correct.
  \end{itemize}} \\
  \hline
  \end{tabular}
  \caption{A POS scheme.}
  \label{fig:pos}
\end{figure*}
   
We use a POS scheme as specified in Figure~\ref{fig:pos}.

\subsection{Security} \label{sect:security}
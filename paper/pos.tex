\section{Proofs of Storage} \label{sect:pos}

We adopt Juels and Kaliski's proof-of-retrievability (POR) scheme~\cite{JK07}.
However, we do not require a full-fledged POR scheme for our purposes.
Our setting has the following distinctive characteristics in comparison to those previous POR schemes:
\begin{itemize}
 \item Distributed storage
 \item Asynchronous proof generation: A POS can be generated by each worker individually without being dependent on other workers.
 \item Static \& dynamic data: The owner can dynamically update its datasets stored on the server, but the data delegated to workers is static.
 \item Untrusted data owner and workers: The data owner may refuse to accept a correctly generated POS from an honest worker.
\end{itemize}

- we don't need retrievability, i.e., erasure code

- malicious worker may refuse to release computed results (we discuss how to deal with this problem in \S~\ref{sect:fairness})

- we need to use an encryption scheme which supports secure computation over encrypted data

- one challenge is how to reduce the number of verification required over multiple workers (currently a prover can convince a verifier with a constant number of challenges/responses for each file).

\subsection{Definition} \label{sect:pos-definition}

A proof-of-storage (POS) scheme consists of the following algorithms:
\begin{itemize}
\item \Setup($\lambda$) $\rightarrow k$: The key generation algorithm takes as input a security parameter $\lambda$ and outputs a secret key $k$.

\item \Challenge($k, m$) $\rightarrow V$: The encryption algorithm takes as input a secret key $k$ and a message $m$, and outputs the corresponding ciphertext $V$.

\item \Response($k, V$) $\rightarrow m$: The decryption algorithm takes as input a ciphertext $V$ and a secret key $k$, and outputs the corresponding message $m$ if the key $k$ is correct.

\item \Verify($k, V$) $\rightarrow m$: The decryption algorithm takes as input a ciphertext $V$ and a secret key $k$, and outputs the corresponding message $m$ if the key $k$ is correct.
\end{itemize}


\subsection{Construction} \label{sect:pos-construction}

\begin{figure*}[htb]\centering
  \begin{tabular}{|l|}
    \hline 
    \parbox{0.95\textwidth}{
    \begin{itemize}[leftmargin=*]
    \item \Setup($\lambda$) $\rightarrow k$: The key generation algorithm takes as input a security parameter $\lambda$ and outputs a secret key $k$.

    \item \Challenge($k, m$) $\rightarrow V$: The encryption algorithm takes as input a secret key $k$ and a message $m$, and outputs the corresponding ciphertext $V$.

    \item \Response($k, V$) $\rightarrow m$: The decryption algorithm takes as input a ciphertext $V$ and a secret key $k$, and outputs the corresponding message $m$ if the key $k$ is correct.

    \item \Verify($k, V$) $\rightarrow m$: The decryption algorithm takes as input a ciphertext $V$ and a secret key $k$, and outputs the corresponding message $m$ if the key $k$ is correct.
  \end{itemize}} \\
  \hline
  \end{tabular}
  \caption{A POS scheme.}
  \label{fig:pos}
\end{figure*}
   
We use a POS scheme as specified in Figure~\ref{fig:pos}.

\subsection{Security} \label{sect:security}
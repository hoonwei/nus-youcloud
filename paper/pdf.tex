\section{Proofs of Data Fetch} \label{sect:pos}

Our concept of proofs of data-fetch (PDF) is closely related to that of proofs of storage.
We are interested in using a PDF as a means to convince a verifier that indeed data has been transferred between two parties, e.g., a worker has successfully downloaded a dataset from the data server.

- no permanent storage
- no need to prove retrievability

Our setting has the following distinctive characteristics in comparison to those of previous centralized proofs-of-retrievability (POR) systems:
\begin{itemize}
 \item Distributed storage
 \item Asynchronous proof generation: A POS can be generated by each worker individually without being dependent on other workers.
 \item Static \& dynamic data: The owner can dynamically update its datasets stored on the server, but the data delegated to workers is static.
 \item Untrusted data owner and workers: The data owner may refuse to accept a correctly generated POS from an honest worker.
\end{itemize}

However, we do not require a full-fledged POR scheme for our purposes.

We adopt Juels and Kaliski's proof-of-retrievability (POR) scheme~\cite{JK07}.


Our scheme bears some similarity with HAIL~\cite{BJO09b}, a distributed POR system.
However, the latter focuses on integrity and availability of files stored in a collection of distributed servers using file authentication techniques and error-correcting code.

- we don't need retrievability, i.e., erasure code

- malicious worker may refuse to release computed results (we discuss how to deal with this problem in \S~\ref{sect:fairness})

- we need to use an encryption scheme which supports secure computation over encrypted data

- one challenge is how to reduce the number of verification required over multiple workers (currently a prover can convince a verifier with a constant number of challenges/responses for each file). 

- Only one verification is sufficient for each outsource of dataset to the workers. Hence, the number of queried sentinels should be small because they're for one-time use. However, one issue is that if the worker knows in advance the positions of the challenge data blocks, then it simply downloads only those blocks. Existing POR systems do not encounter such a problem because a file is stored for a relatively extended period of time and different challenges on different positions may be issued to the worker. This forces the worker to download the entire file.

\subsection{Definition} \label{sect:pos-definition}

Let $F := (F_1,F_2,\dotsc,F_n)$ denote a dataset consisting $n$ sequential segments.
We give a definition of a proof-of-storage (POS) scheme that suits our purposes:
\begin{itemize}
% \item \Setup($\lambda,F$) $\rightarrow (\MK,\hat{F},\digest)$: The setup algorithm takes as input a security parameter $\lambda$ and outputs a master key $\MK$, from which additional keys are derived, including encryption key $\EK$ and challenge key $\CK$. The algorithm then computes the encryption of $F$ under key $\EK$, denoted by $\hat{F}$, and a Merkle tree whose leaves are segments of $\hat{F}$ and whose root is $\digest$.

\item \Setup($F$) $\rightarrow (\digest)$: The setup algorithm takes as input a dataset $F$ (which may be encrypted). It computes a Merkle tree whose leaves are segments of $F$ and whose root is $\digest$.

\item \Prove($\CK, S$) $\rightarrow V$: The challenge algorithm takes as input a challenge key $\CK$ and a set $S$ of block indices, and outputs the corresponding set $V$ of challenge block indices.

\item \Verify($\CK, \EK, R$) $\rightarrow \{0,1\}$: The verify algorithm takes as input the challenge key and encryption key $\EK$, and the responses $R$. It outputs `1' if verification suceeds, or `0' otherwise.
\end{itemize}

The \Setup~and \Verify~algorithms are run by the data owner for each dataset, while the \Prove~algorithm is run by the worker.
In comparison with the original definition by Juels and Kaliski~\cite{JK07}, we omit the encode and extract algorithms which are irrelevant to us.

\subsection{Construction} \label{sect:pos-construction}

%\paragraph{Notation.}
%We let $n$ denote the number of blocks of the client's entire dataset, and $s$ denote the number of sentinels.



\begin{figure*}[htb]\centering
  \begin{tabular}{|l|}
    \hline 
    \parbox{0.95\textwidth}{
    \begin{itemize}[leftmargin=*]
    \item \Setup($\lambda$) $\rightarrow \MK$: The setup algorithm takes as input a security parameter $\lambda$ and outputs a master key $\MK$. It then sets the encryption key $\EK=H(\MK, \text{`enc'})$ and the challenge key $\CK=H(\MK, \text{`chal'})$, where $H$ is an appropriate key derivation function.

    \item \Prove($\CK, S$) $\rightarrow V$: The challenge algorithm takes as input a challenge key $\CK$ and a set $S$ of block indices, and outputs the corresponding set $V$ of challenge block indices.

    \item \Verify($\CK, \EK, R$) $\rightarrow \{0,1\}$: The verify algorithm takes as input the challenge key and encryption key $\EK$, and the responses $R$. It outputs `1' if verification suceeds, or `0' otherwise.
  \end{itemize}} \\
  \hline
  \end{tabular}
  \caption{A POS scheme.}
  \label{fig:pos}
\end{figure*}
   
We use a POS scheme as specified in Figure~\ref{fig:pos}.

\subsection{Security} \label{sect:security}
